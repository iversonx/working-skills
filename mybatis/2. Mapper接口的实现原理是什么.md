使用MyBatis作为持久化框架时，常用做法是编写Mapper接口以及与对应的映射文件，并不需要编写Mapper接口的实现类。

1. MyBatis使用动态代理来实现Mapper接口与映射文件的关联，每次在从`SqlSession`中获取Mapper接口实例时，都会从`Configuration`中`MapperRegistry`根据Mapper接口的Class来创建`MapperProxy`代理实例。

2. 当调用Mapper接口的方法时，实际是执行`MapperProxy#invoke`方法。在`MapperProxy#invoke`方法中会判断如果是Object类的方法或者是接口默认方法，就不进行代理；否则使用`MapperMethod`进行代理。

3. `MapperMethod`记录Mapper接口方法与要执行的SQL语句的关联。`MapperMethod`最后会调用`SqlSession`中相应的方法来执行SQL语句。

> 接口默认方法，是从JDK8开始提供的接口特性。

##### 分析

###### 1. MapperRegistry

`Configuration`是MyBatis中一个比较重的类，用于存储配置信息和映射信息。在`Configuration`的`mapperRegistry`成员中使用HashMap存储Mapper接口的Class与`MapperProxyFactory`的关联，Key为Mapper接口的Class，Value为`MapperProxyFactory`。

```java
public class MapperRegistry {
    private final Configuration config;
    /**
     * 所有Mapper的Class实例和MapperProxyFactory的关联
     */
    private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap<Class<?>, MapperProxyFactory<?>>();

    public MapperRegistry(Configuration config) {
        this.config = config;
    }

   

    public <T> boolean hasMapper(Class<T> type) {
        return knownMappers.containsKey(type);
    }

    public <T> void addMapper(Class<T> type) {
        if (type.isInterface()) {
            if (hasMapper(type)) {
                throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
            }
            boolean loadCompleted = false;
            try {
                knownMappers.put(type, new MapperProxyFactory<T>(type));
                MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
                parser.parse();
                loadCompleted = true;
            } finally {
                if (!loadCompleted) {
                    knownMappers.remove(type);
                }
            }
        }
    }
    // 省略其他代码

}
```

###### 2. MapperProxyFactory

`MapperProxyFactory`用于创建`MapperProxy`实例。每次调用`SqlSession#getMapper`时，都会调用`MapperProxyFactory`创建`MapperProxy`实例。
